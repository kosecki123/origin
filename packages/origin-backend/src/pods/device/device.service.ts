import {
    DeviceCreateData,
    DeviceSettingsUpdateData,
    DeviceStatus,
    DeviceStatusChangedEvent,
    DeviceUpdateData,
    ICertificationRequestBackend,
    IDevice,
    IDeviceProductInfo,
    IDeviceWithRelationsIds,
    IEnergyGeneratedWithStatus,
    IExternalDeviceId,
    ILoggedInUser,
    ISmartMeterRead,
    ISmartMeterReadingsAdapter,
    ISmartMeterReadStats,
    ISmartMeterReadWithStatus,
    SupportedEvents,
    ISuccessResponse,
    sortLowestToHighestTimestamp
} from '@energyweb/origin-backend-core';
import {
    Inject,
    Injectable,
    NotFoundException,
    UnprocessableEntityException
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { validate } from 'class-validator';
import { BigNumber } from 'ethers';
import moment from 'moment';
import { FindOneOptions, Repository } from 'typeorm';
import { v4 as uuid } from 'uuid';
import { SM_READS_ADAPTER } from '../../const';
import { StorageErrors } from '../../enums/StorageErrors';
import { ConfigurationService } from '../configuration';
import { ExtendedBaseEntity } from '../ExtendedBaseEntity';
import { NotificationService } from '../notification';
import { OrganizationService } from '../organization/organization.service';
import { Device } from './device.entity';

@Injectable()
export class DeviceService {
    constructor(
        @InjectRepository(Device)
        private readonly repository: Repository<Device>,
        private readonly configurationService: ConfigurationService,
        private readonly organizationService: OrganizationService,
        private readonly notificationService: NotificationService,
        @Inject(SM_READS_ADAPTER) private smartMeterReadingsAdapter?: ISmartMeterReadingsAdapter
    ) {}

    async findByExternalId(
        externalId: IExternalDeviceId
    ): Promise<ExtendedBaseEntity & IDeviceWithRelationsIds> {
        const devices = ((await this.repository.find({
            loadRelationIds: true
        })) as IDevice[]) as (ExtendedBaseEntity & IDeviceWithRelationsIds)[];

        const device = devices.find((d) =>
            d.externalDeviceIds.find((id) => id.id === externalId.id && id.type === externalId.type)
        );

        return device;
    }

    async findOne(
        id: string,
        options: FindOneOptions<Device> = {},
        withMeterStats = false
    ): Promise<ExtendedBaseEntity & IDevice> {
        const { loadRelationIds = true } = options;
        const device = ((await this.repository.findOne(id, {
            loadRelationIds,
            ...options
        })) as IDevice) as ExtendedBaseEntity & IDevice;

        if (this.smartMeterReadingsAdapter) {
            device.smartMeterReads = [];
        }

        if (withMeterStats) {
            device.meterStats = await this.getMeterStats(device.id.toString());
        }

        return device;
    }

    async create(data: DeviceCreateData, loggedUser: ILoggedInUser) {
        const configuration = await this.configurationService.get();
        const organization = await this.organizationService.findOne(loggedUser.organizationId);

        const newEntity = new Device();

        Object.assign(newEntity, {
            ...data,
            status: data.status ?? DeviceStatus.Submitted,
            smartMeterReads: data.smartMeterReads ?? [],
            deviceGroup: data.deviceGroup ?? '',
            organization,
            externalDeviceIds: data.externalDeviceIds
                ? data.externalDeviceIds.map(({ id, type }) => {
                      if (
                          typeof id === 'undefined' &&
                          configuration.externalDeviceIdTypes?.find((t) => t.type === type)
                              ?.autogenerated
                      ) {
                          return { id: uuid(), type };
                      }

                      return { id, type };
                  })
                : []
        });

        const validationErrors = await validate(newEntity);

        if (validationErrors.length > 0) {
            throw new UnprocessableEntityException({
                success: false,
                errors: validationErrors
            });
        }

        await this.repository.save(newEntity);

        return newEntity;
    }

    async remove(entity: Device | (ExtendedBaseEntity & IDeviceWithRelationsIds)) {
        this.repository.remove((entity as IDevice) as Device);
    }

    async getAllSmartMeterReadings(id: string): Promise<ISmartMeterRead[]> {
        const device = await this.repository.findOne(id);

        if (this.smartMeterReadingsAdapter) {
            return this.smartMeterReadingsAdapter.getAll(device);
        }

        return device.smartMeterReads;
    }

    async addSmartMeterReadings(
        id: string,
        newSmartMeterReads: ISmartMeterRead[]
    ): Promise<ISuccessResponse> {
        const device = await this.findOne(id);

        if (this.smartMeterReadingsAdapter) {
            try {
                await this.smartMeterReadingsAdapter.save(device, newSmartMeterReads);
            } catch (error) {
                throw new UnprocessableEntityException({
                    success: false,
                    message: error.message
                });
            }

            return {
                success: true,
                message: `Smart meter readings successfully added to device ${id}`
            };
        }

        if (device.smartMeterReads.length > 0) {
            newSmartMeterReads.forEach((newSmartMeterRead) => {
                if (
                    newSmartMeterRead.timestamp <=
                    device.smartMeterReads[device.smartMeterReads.length - 1].timestamp
                ) {
                    throw new UnprocessableEntityException({
                        success: false,
                        message: `Smart meter readings timestamp should always be higher than latest.`
                    });
                }
            });
        }

        await this.repository.update(device.id, {
            smartMeterReads: [...device.smartMeterReads, ...newSmartMeterReads].sort(
                sortLowestToHighestTimestamp
            )
        });

        return {
            success: true,
            message: `Smart meter readings successfully added to device ${id}`
        };
    }

    async getAll(
        withMeterStats = false,
        options: FindOneOptions<Device> = {}
    ): Promise<Array<ExtendedBaseEntity & IDevice>> {
        const { loadRelationIds = true } = options;
        const devices = ((await this.repository.find({
            loadRelationIds,
            ...options
        })) as IDevice[]) as (ExtendedBaseEntity & IDevice)[];

        for (const device of devices) {
            if (this.smartMeterReadingsAdapter) {
                device.smartMeterReads = [];
            }

            if (withMeterStats) {
                device.meterStats = await this.getMeterStats(device.id.toString());
            }
        }

        return devices;
    }

    async findDeviceProductInfo(externalId: IExternalDeviceId): Promise<IDeviceProductInfo> {
        const devices = await this.repository.find();

        return devices.find((device) =>
            device.externalDeviceIds.find(
                (id) => id.id === externalId.id && id.type === externalId.type
            )
        );
    }

    async updateStatus(
        id: string,
        update: DeviceUpdateData
    ): Promise<ExtendedBaseEntity & IDeviceWithRelationsIds> {
        const device = (await this.findOne(id)) as ExtendedBaseEntity & IDeviceWithRelationsIds;

        if (!device) {
            throw new NotFoundException(StorageErrors.NON_EXISTENT);
        }

        try {
            await this.repository.update(device.id, { status: update.status });

            const deviceManagers = await this.organizationService.getDeviceManagers(
                device.organization
            );

            const event: DeviceStatusChangedEvent = {
                deviceId: id,
                status: device.status,
                deviceManagersEmails: deviceManagers.map((u) => u.email)
            };

            this.notificationService.handleEvent({
                type: SupportedEvents.DEVICE_STATUS_CHANGED,
                data: event
            });

            return device;
        } catch (error) {
            throw new UnprocessableEntityException({
                success: false,
                message: `Device ${id} could not be updated due to an error ${error.message}`
            });
        }
    }

    async updateSettings(id: string, update: DeviceSettingsUpdateData): Promise<ISuccessResponse> {
        const device = await this.findOne(id);

        if (!device) {
            throw new NotFoundException(StorageErrors.NON_EXISTENT);
        }

        const { defaultAskPrice, automaticPostForSale } = update;

        try {
            await this.repository.update(id, { defaultAskPrice, automaticPostForSale });

            return {
                success: true,
                message: `Device ${id} successfully updated`
            };
        } catch (error) {
            throw new UnprocessableEntityException({
                success: false,
                message: `Device ${id} could not be updated due to an error: ${error.message}`
            });
        }
    }

    private async getMeterStats(deviceId: string): Promise<ISmartMeterReadStats> {
        const smReads = await this.getAllSmartMeterReadings(deviceId);
        const certificationRequests = await this.getCertificationRequests(deviceId);

        return this.calculateCertifiedEnergy(this.resolveCertified(smReads, certificationRequests));
    }

    private async getCertificationRequests(
        deviceId: string
    ): Promise<ICertificationRequestBackend[]> {
        const device = await this.repository.findOne(deviceId, {
            relations: ['certificationRequests']
        });

        return device.certificationRequests;
    }

    private resolveCertified(
        smReads: ISmartMeterRead[],
        certificationRequests: ICertificationRequestBackend[]
    ): ISmartMeterReadWithStatus[] {
        return smReads.map((smRead) => {
            let certified = false;

            for (const certReq of certificationRequests) {
                if (!certReq.approved) {
                    continue;
                }

                const smReadTime = moment.unix(smRead.timestamp);
                const certificationFromTime = moment.unix(certReq.fromTime);
                const certificationToTime = moment.unix(certReq.toTime);

                if (smReadTime.isBetween(certificationFromTime, certificationToTime)) {
                    certified = true;
                    break;
                }
            }

            return {
                ...smRead,
                certified
            };
        });
    }

    private calculateCertifiedEnergy(smReads: ISmartMeterReadWithStatus[]): ISmartMeterReadStats {
        const energiesGenerated: IEnergyGeneratedWithStatus[] = [];

        for (let i = 0; i < smReads.length; i++) {
            const isFirstReading = i === 0;

            const { meterReading, timestamp, certified } = smReads[i];

            energiesGenerated.push({
                energy: BigNumber.from(meterReading).sub(
                    isFirstReading ? 0 : BigNumber.from(smReads[i - 1].meterReading)
                ),
                timestamp,
                certified
            });
        }

        const sumEnergy = (energyGens: IEnergyGeneratedWithStatus[]) =>
            energyGens.reduce((sum, energyGen) => sum.add(energyGen.energy), BigNumber.from(0));

        return {
            certified: sumEnergy(energiesGenerated.filter((energyGen) => energyGen.certified)),
            uncertified: sumEnergy(energiesGenerated.filter((energyGen) => !energyGen.certified))
        };
    }

    async getSupplyBy(organizationId: number, facilityName: string, status: number) {
        const _facilityName = `%${facilityName}%`;
        const _status = status === 1;
        const devices = ((await this.repository
            .createQueryBuilder('device')
            .leftJoinAndSelect('device.organization', 'organization')
            .where(
                `organization.id = :organizationId and device.facilityName ilike :_facilityName ${
                    status > 0 ? `and device.automaticPostForSale = :_status` : ``
                }`,
                { organizationId, _facilityName, _status }
            )
            .getMany()) as IDevice[]) as (ExtendedBaseEntity & IDeviceWithRelationsIds)[];

        for (const device of devices) {
            if (this.smartMeterReadingsAdapter) {
                device.smartMeterReads = [];
            }

            device.meterStats = await this.getMeterStats(device.id.toString());
        }

        return devices;
    }
}
